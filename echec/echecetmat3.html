<!DOCTYPE html>
<html lang="fr">
<head>
<script>
/* Si mobile ‚Üí redirection */
if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
    window.location.href = "echecetmat3_mobile.html";
}
</script>
<meta charset="UTF-8">
<title>Puzzles √âchecs ‚Äì PC (g√©n√©rateur infini)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
    body {
        font-family: Arial, sans-serif;
        background: #f2f2f2;
        padding: 20px;
    }

    h2 { margin-bottom: 5px; text-align:center; }
    p  { text-align:center; }

    #layout {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        justify-content: center;
        align-items: flex-start;
        margin-top: 10px;
    }

    /* Conteneur plateau + coordonn√©es */
    #boardContainer {
        display: flex;
        flex-direction: column;
        align-items: center;
        background:#ddd;
        padding: 12px;
        border-radius: 10px;
    }

    .filesRow {
        display: flex;
        justify-content: space-between;
        width: 480px;
        font-weight: bold;
        font-size: 14px;
        margin: 4px 0;
    }

    .fileLabel {
        width: 12.5%;
        text-align: center;
    }

    .boardRow {
        display: flex;
        flex-direction: row;
        align-items: center;
    }

    .ranksCol {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        height: 480px;
        margin-right: 4px;
        font-weight: bold;
        font-size: 14px;
    }

    .rankLabel {
        height: 12.5%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #board {
        width: 480px;
        height: 480px;
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        border: 2px solid #000;
        border-radius: 6px;
        overflow: hidden;
        background:#000;
    }

    .case {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        user-select: none;
    }

    .clair { background: #f0d9b5; }
    .fonce { background: #b58863; }

    .case.selected {
        outline: 3px solid red;
        box-sizing: border-box;
    }

    .piece {
        width: 55px;
        height: 55px;
        pointer-events: none;
    }

    #sidePanel {
        width: 340px;
        max-width: 100%;
    }

    button {
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 15px;
        cursor: pointer;
        margin: 3px;
        border: 1px solid #333;
        background: #fff;
    }

    #buttonsTop, #buttonsBottom {
        text-align:center;
        margin-bottom:8px;
    }

    #status {
        background:#fff;
        padding:8px;
        border-radius:6px;
        border:1px solid #ccc;
        margin-top:4px;
        font-size:14px;
        min-height: 36px;
    }

    #hintBox, #solutionBox {
        background:#fff;
        padding:8px;
        border-radius:6px;
        border:1px solid #ccc;
        margin-top:8px;
        font-size:14px;
        white-space:pre-wrap;
        display:none;
    }

    #movesBox {
        margin-top:8px;
        background:#fff;
        padding:8px;
        border-radius:6px;
        border:1px solid #ccc;
        height:200px;
        overflow-y:auto;
        font-family: "Courier New", monospace;
        font-size:14px;
        white-space:pre;
    }

    /* Popup victoire */
    #popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 25px 35px;
        background: white;
        border: 2px solid #333;
        border-radius: 10px;
        font-size: 22px;
        display: none;
        z-index: 20;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
</style>
</head>

<body>

<h2>Puzzles ‚Äì Mat en ‚â§3 coups (PC)</h2>
<p>Mode libre : tu joues ce que tu veux. Le moteur joue contre toi. Si tu mates ‚Üí üéâ Victoire !</p>

<div id="layout">
    <div id="boardContainer">
        <div class="filesRow">
            <span class="fileLabel">a</span><span class="fileLabel">b</span>
            <span class="fileLabel">c</span><span class="fileLabel">d</span>
            <span class="fileLabel">e</span><span class="fileLabel">f</span>
            <span class="fileLabel">g</span><span class="fileLabel">h</span>
        </div>

        <div class="boardRow">
            <div class="ranksCol">
                <span class="rankLabel">8</span>
                <span class="rankLabel">7</span>
                <span class="rankLabel">6</span>
                <span class="rankLabel">5</span>
                <span class="rankLabel">4</span>
                <span class="rankLabel">3</span>
                <span class="rankLabel">2</span>
                <span class="rankLabel">1</span>
            </div>
            <div id="board"></div>
        </div>

        <div class="filesRow">
            <span class="fileLabel">a</span><span class="fileLabel">b</span>
            <span class="fileLabel">c</span><span class="fileLabel">d</span>
            <span class="fileLabel">e</span><span class="fileLabel">f</span>
            <span class="fileLabel">g</span><span class="fileLabel">h</span>
        </div>
    </div>

    <div id="sidePanel">
        <div id="buttonsTop">
            <button id="newPuzzleBtn">‚ú® Nouveau puzzle (infini)</button>
            <button id="undoBtn">‚Ü©Ô∏è Annuler</button>
        </div>
        <div id="buttonsBottom">
            <button id="hintBtn">üí° Indice</button>
            <button id="solutionBtn">üìò Solution (moteur)</button>
        </div>

        <div id="status">Chargement du moteur‚Ä¶</div>
        <div id="hintBox"></div>
        <div id="solutionBox"></div>
        <div id="movesBox"></div>
    </div>
</div>

<div id="popup">üéâ Victoire ! √âchec et mat.</div>

<script>
// ==========================
//  Globals
// ==========================
const files = ["a","b","c","d","e","f","g","h"];

const piecesImg = {
    "wK": "./chess/wK.png",
    "wQ": "./chess/wQ.png",
    "wR": "./chess/wR.png",
    "wB": "./chess/wB.png",
    "wN": "./chess/wN.png",
    "wP": "./chess/wP.png",
    
    "bK": "./chess/bK.png",
    "bQ": "./chess/bQ.png",
    "bR": "./chess/bR.png",
    "bB": "./chess/bB.png",
    "bN": "./chess/bN.png",
    "bP": "./chess/bP.png"
};


let position = {};             // { "e4": "wQ", ... }
let sideToMove = "w";
let selectedSquare = null;
let history = [];              // pour undo : {position, sideToMove, moves}
let moves = [];                // {side, uci}
let hintLevel = 0;

const board = document.getElementById("board");
const statusDiv = document.getElementById("status");
const movesBox  = document.getElementById("movesBox");
const hintBox   = document.getElementById("hintBox");
const solutionBox = document.getElementById("solutionBox");
const newPuzzleBtn = document.getElementById("newPuzzleBtn");

// Engine
let engine = null;
let engineReady = false;
let engineMode = null; // "opponent", "solution", "generator"
let generatorResolve = null;
let generatorInfo = null;

let solutionInfo = { pv:"", scoreCp:null, mate:null, depth:null };

// ==========================
//  Stockfish init
// ==========================
async function createEngine() {
    const response = await fetch("https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js");
    const text = await response.text();
    const blob = new Blob([text], { type: "application/javascript" });
    return new Worker(URL.createObjectURL(blob));
}

(async () => {
    engine = await createEngine();
    engine.onmessage = (e) => {
        const line = e.data;
        if (typeof line !== "string") return;

        if (line.includes("uciok")) {
            engineReady = true;
            statusDiv.textContent = "Moteur pr√™t. Clique sur ‚ÄúNouveau puzzle‚Äù.";
            return;
        }

        if (engineMode === "opponent") {
            if (line.startsWith("bestmove")) {
                const parts = line.split(" ");
                const best = parts[1];
                if (!best || best === "(none)" || best === "0000") {
                    showVictoryPopup();
                    engineMode = null;
                    return;
                }
                applyEngineMove(best);
                engineMode = null;
            }
        } else if (engineMode === "solution") {
            if (line.startsWith("info")) {
                parseInfoLine(line, solutionInfo);
            } else if (line.startsWith("bestmove")) {
                showSolutionFromInfo();
                engineMode = null;
            }
        } else if (engineMode === "generator") {
            if (line.startsWith("info")) {
                parseInfoLine(line, generatorInfo);
            } else if (line.startsWith("bestmove")) {
                // On a fini l'analyse de la position candidate
                const resolve = generatorResolve;
                generatorResolve = null;
                engineMode = null;
                if (!resolve) return;

                // On n'accepte que si mate pour le camp au trait et |mate| <= 3
                if (generatorInfo.mate !== null && Math.abs(generatorInfo.mate) <= 3) {
                    resolve(generatorInfo);
                } else {
                    resolve(null);
                }
            }
        }
    };
    engine.postMessage("uci");
})();

// ==========================
//  Board drawing
// ==========================
function renderBoard() {
    board.innerHTML = "";
    for (let r = 8; r >= 1; r--) {
        for (let f = 0; f < 8; f++) {
            const sq = files[f] + r;
            const div = document.createElement("div");
            div.id = sq;
            div.className = "case " + ((r + f) % 2 ? "fonce" : "clair");
            div.onclick = () => onClickSquare(sq);
            board.appendChild(div);
        }
    }
}

function refreshBoard() {
    renderBoard();

    for (let sq in position) {
        if (!position[sq]) continue;
        const img = document.createElement("img");
        img.src = piecesImg[position[sq]];
        img.className = "piece";
        const cell = document.getElementById(sq);
        if (cell) cell.appendChild(img);
    }

    if (selectedSquare) {
        const el = document.getElementById(selectedSquare);
        if (el) el.classList.add("selected");
    }
}

// ==========================
//  Utils
// ==========================
function deepCopy(obj) {
    return JSON.parse(JSON.stringify(obj));
}

function randomInt(min, max) { // inclusive
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// fabrique une position al√©atoire avec 2 rois + pi√®ces diverses
function generateRandomPositionObject() {
    const boardObj = {};

    // place rois
    const allSquares = [];
    for (let r = 1; r <= 8; r++) {
        for (let f = 0; f < 8; f++) {
            allSquares.push(files[f] + r);
        }
    }

    const idxWK = randomInt(0, allSquares.length - 1);
    let idxBK = randomInt(0, allSquares.length - 1);
    while (idxBK === idxWK) idxBK = randomInt(0, allSquares.length - 1);

    const sqWK = allSquares[idxWK];
    const sqBK = allSquares[idxBK];
    boardObj[sqWK] = "wK";
    boardObj[sqBK] = "bK";

    const pieceTypes = ["Q","R","B","N","P"];

    // pi√®ces blanches
    const nbWhite = randomInt(2, 6);
    for (let i = 0; i < nbWhite; i++) {
        let sq;
        do {
            sq = allSquares[randomInt(0, allSquares.length - 1)];
        } while (boardObj[sq]);
        const type = pieceTypes[randomInt(0, pieceTypes.length - 1)];
        boardObj[sq] = "w" + type;
    }

    // pi√®ces noires
    const nbBlack = randomInt(0, 5);
    for (let i = 0; i < nbBlack; i++) {
        let sq;
        do {
            sq = allSquares[randomInt(0, allSquares.length - 1)];
        } while (boardObj[sq]);
        const type = pieceTypes[randomInt(0, pieceTypes.length - 1)];
        boardObj[sq] = "b" + type;
    }

    return boardObj;
}

function positionObjToFEN(posObj, trait) {
    let fen = "";
    for (let r = 8; r >= 1; r--) {
        let empty = 0;
        for (let f = 0; f < 8; f++) {
            const sq = files[f] + r;
            const piece = posObj[sq];
            if (!piece) {
                empty++;
            } else {
                if (empty) { fen += empty; empty = 0; }
                const color = piece[0];
                const type  = piece[1];
                fen += (color === "w") ? type.toUpperCase() : type.toLowerCase();
            }
        }
        if (empty) fen += empty;
        if (r > 1) fen += "/";
    }
    return fen + " " + trait + " - - 0 1";
}

function currentPositionToFEN() {
    return positionObjToFEN(position, sideToMove);
}

function updateMovesBox() {
    let txt = "";
    let moveNumber = 1;
    for (let i = 0; i < moves.length; i += 2) {
        const mWhite = moves[i];
        const mBlack = moves[i+1];
        txt += moveNumber + ". ";
        if (mWhite) txt += mWhite.uci + " ";
        if (mBlack) txt += mBlack.uci;
        txt += "\n";
        moveNumber++;
    }
    movesBox.textContent = txt;
}

// ==========================
//  Engine info parsing
// ==========================
function resetSolutionInfo() {
    solutionInfo = { pv:"", scoreCp:null, mate:null, depth:null };
}

function resetGeneratorInfo() {
    generatorInfo = { pv:"", scoreCp:null, mate:null, depth:null };
}

function parseInfoLine(line, targetInfo) {
    const parts = line.split(" ");

    const depthIdx = parts.indexOf("depth");
    if (depthIdx !== -1 && parts[depthIdx+1]) {
        targetInfo.depth = parseInt(parts[depthIdx+1]);
    }

    const scoreIdx = parts.indexOf("score");
    if (scoreIdx !== -1 && parts[scoreIdx+2]) {
        const type = parts[scoreIdx+1];
        const val  = parseInt(parts[scoreIdx+2]);
        if (type === "cp") {
            targetInfo.scoreCp = val;
            targetInfo.mate = null;
        } else if (type === "mate") {
            targetInfo.mate = val;
            targetInfo.scoreCp = null;
        }
    }

    const pvIdx = parts.indexOf("pv");
    if (pvIdx !== -1 && parts[pvIdx+1]) {
        const pvMoves = parts.slice(pvIdx+1);
        targetInfo.pv = pvMoves.join(" ");
    }
}

// ==========================
//  Solution display
// ==========================
function showSolutionFromInfo() {
    let text = "";

    if (solutionInfo.pv) {
        text += "Ligne principale (UCI) :\n";
        text += solutionInfo.pv.split(" ").join("  ") + "\n\n";
    } else {
        text += "Pas de ligne principale trouv√©e.\n\n";
    }

    if (solutionInfo.mate !== null) {
        const side = solutionInfo.mate > 0 ? "les blancs" : "les noirs";
        text += "√âvaluation : mat en " + Math.abs(solutionInfo.mate) + " coups pour " + side + ".\n";
    } else if (solutionInfo.scoreCp !== null) {
        const side = solutionInfo.scoreCp > 0 ? "les blancs" : "les noirs";
        const score = (solutionInfo.scoreCp / 100).toFixed(2);
        text += "√âvaluation : " + score + " pions en faveur de " + side + ".\n";
    }

    if (solutionInfo.depth !== null) {
        text += "Profondeur de recherche : " + solutionInfo.depth;
    }

    solutionBox.textContent = text;
    solutionBox.style.display = "block";
}

// ==========================
//  New puzzle generator
// ==========================
function analyseFenForMate(fen) {
    return new Promise((resolve) => {
        if (!engineReady) {
            resolve(null);
            return;
        }
        resetGeneratorInfo();
        generatorResolve = resolve;
        engineMode = "generator";
        engine.postMessage("stop");
        engine.postMessage("position fen " + fen);
        engine.postMessage("go depth 12");
    });
}

async function generateNewPuzzle() {
    if (!engineReady) {
        statusDiv.textContent = "Moteur pas pr√™t.";
        return;
    }

    newPuzzleBtn.disabled = true;
    statusDiv.textContent = "G√©n√©ration d'un nouveau puzzle (mat ‚â§3)‚Ä¶";
    hintBox.style.display = "none";
    solutionBox.style.display = "none";
    hintBox.textContent = "";
    solutionBox.textContent = "";
    movesBox.textContent = "";
    history = [];
    moves = [];
    selectedSquare = null;

    let found = false;
    let fenChosen = null;
    let infoChosen = null;

    // On essaie plusieurs positions au hasard jusqu'√† trouver un mate ‚â§3
    for (let attempt = 0; attempt < 40; attempt++) {
        // camp au trait : blanc (plus simple)
        sideToMove = "w";
        const posObj = generateRandomPositionObject();
        const fen = positionObjToFEN(posObj, sideToMove);

        const info = await analyseFenForMate(fen);
        if (info && info.mate !== null && info.mate > 0 && Math.abs(info.mate) <= 3) {
            found = true;
            fenChosen = fen;
            infoChosen = info;
            break;
        }
    }

    if (!found) {
        statusDiv.textContent = "Impossible de trouver un mat rapide pour le moment. R√©essaie.";
        newPuzzleBtn.disabled = false;
        return;
    }

    // Appliquer la position choisie
    // Reconvertir fenChosen en position objet
    position = fenToPositionObj(fenChosen);
    sideToMove = fenChosen.split(" ")[1] || "w";
    refreshBoard();
    updateMovesBox();

    const mateStr = infoChosen.mate ? ("mat en " + Math.abs(infoChosen.mate) + " coups") : "";
    statusDiv.textContent = `Nouveau puzzle g√©n√©r√© (${mateStr} pour les ${infoChosen.mate > 0 ? "blancs" : "noirs"}). √Ä toi de jouer !`;

    newPuzzleBtn.disabled = false;
}

// Convertir FEN -> objet position simplifi√© (juste pi√®ces)
function fenToPositionObj(fen) {
    const parts = fen.split(" ");
    const boardPart = parts[0];
    const ranks = boardPart.split("/");

    const pos = {};
    let r = 8;
    for (let row of ranks) {
        let f = 0;
        for (let ch of row) {
            if (/[1-8]/.test(ch)) {
                f += parseInt(ch, 10);
            } else {
                const file = files[f];
                const sq = file + r;
                const isUpper = ch === ch.toUpperCase();
                const color = isUpper ? "w" : "b";
                const type = ch.toUpperCase();
                pos[sq] = color + type;
                f++;
            }
        }
        r--;
    }
    return pos;
}

// ==========================
//  Gameplay
// ==========================
function onClickSquare(sq) {
    document.querySelectorAll(".case").forEach(c => c.classList.remove("selected"));

    if (!selectedSquare) {
        if (position[sq]) {
            selectedSquare = sq;
            document.getElementById(sq).classList.add("selected");
        }
        return;
    }

    if (selectedSquare !== sq) {
        playerMove(selectedSquare, sq);
    }

    selectedSquare = null;
}

function playerMove(from, to) {
    if (!position[from]) return;

    // sauvegarde pour undo
    history.push({
        position: deepCopy(position),
        sideToMove,
        moves: deepCopy(moves)
    });

    const piece = position[from];
    delete position[from];
    position[to] = piece;

    if (piece === "wP" && to[1] === "8") position[to] = "wQ";
    if (piece === "bP" && to[1] === "1") position[to] = "bQ";

    moves.push({ side: sideToMove, uci: from + to });
    sideToMove = (sideToMove === "w") ? "b" : "w";

    refreshBoard();
    updateMovesBox();

    const piecesArr = Object.values(position);
    if (!piecesArr.includes("bK")) {
        showVictoryPopup();
        return;
    }

    if (engineReady) engineReply();
}

function engineReply() {
    const fen = currentPositionToFEN();
    engineMode = "opponent";
    engine.postMessage("stop");
    engine.postMessage("position fen " + fen);
    engine.postMessage("go depth 10");
}

function applyEngineMove(uci) {
    const from = uci.substring(0,2);
    const to   = uci.substring(2,4);
    if (!position[from]) return;

    history.push({
        position: deepCopy(position),
        sideToMove,
        moves: deepCopy(moves)
    });

    const piece = position[from];
    delete position[from];
    position[to] = piece;

    if (piece === "wP" && to[1] === "8") position[to] = "wQ";
    if (piece === "bP" && to[1] === "1") position[to] = "bQ";

    moves.push({ side: sideToMove, uci });
    sideToMove = (sideToMove === "w") ? "b" : "w";

    refreshBoard();
    updateMovesBox();
}

// ==========================
//  Popup Victoire
// ==========================
function showVictoryPopup() {
    const pop = document.getElementById("popup");
    pop.style.display = "block";
    setTimeout(() => { pop.style.display = "none"; }, 1800);
}

// ==========================
//  Indices
// ==========================
function showHint() {
    hintBox.style.display = "block";
    const msgs = [
        "Cherche d'abord les √©checs possibles sur le roi adverse.",
        "Regarde si tu peux ajouter une menace de mat en sacrifiant du mat√©riel.",
        "Concentre-toi sur les cases autour du roi adverse (ses cases de fuite)."
    ];
    const idx = hintLevel % msgs.length;
    hintBox.textContent = "Indice : " + msgs[idx];
    hintLevel++;
}

// ==========================
//  Solution via moteur
// ==========================
function computeSolution() {
    if (!engineReady) {
        solutionBox.textContent = "Moteur pas pr√™t.";
        solutionBox.style.display = "block";
        return;
    }
    resetSolutionInfo();
    const fen = currentPositionToFEN();
    engineMode = "solution";
    engine.postMessage("stop");
    engine.postMessage("position fen " + fen);
    engine.postMessage("go depth 14");
}

// ==========================
//  Buttons
// ==========================
document.getElementById("undoBtn").onclick = () => {
    if (history.length === 0) return;
    const last = history.pop();
    position = last.position;
    sideToMove = last.sideToMove;
    moves = last.moves;
    selectedSquare = null;
    refreshBoard();
    updateMovesBox();
};

newPuzzleBtn.onclick = () => {
    generateNewPuzzle();
};

document.getElementById("hintBtn").onclick = showHint;
document.getElementById("solutionBtn").onclick = computeSolution;

// ==========================
//  Init
// ==========================
renderBoard();
statusDiv.textContent = "Initialisation du moteur‚Ä¶";

</script>

</body>
</html>

